# 树的存储结构

## 双亲表示法
```cpp
struct PTnode{
    elemtype data;
    int parent;
};//结点结构体

struct PTree{
    PTnode nodes[Max];
    int root,num;
};//树结构体
```
![Iamge](https://github.com/Feng-Jay/DataStruct/blob/master/Image/双亲.png)

该存储结构利用了除根结点外的所有结点都有唯一的双亲的性质。

找双亲的操作可在常数时间完成，但在寻找结点的孩子时需要遍历整个结构体。
## 孩子表示法
树中每个结点可以有多个孩子，所以每个结点有多个指针域，指向子树的root结点。

但这样做的缺点就是会有大量存储空间浪费。所以改用下面的方法。

n个结点共有n个孩子链表，将这n个孩子链表的头指针组成一个线性表(用顺序存储); 对每个孩子链表，将孩子结点排列起来其视作一个线性表，用单链表方式存储。

```cpp
struct CTnode{
    int child;
    CTnode* next;
};//孩子链表结点
struct CTbox{
    elemtype data;
    CTnode* firstchild;
};//表头指针
struct CTree{
    CTbox nodes[MAX];
    int root,num;
};//整个树
```
![Iamge](https://github.com/Feng-Jay/DataStruct/blob/master/Image/孩子.png)

与双亲表示法相反，孩子表示法适用于涉及孩子的操作，却不适用于双亲操作。可以将其二者结合(在孩子链表表头中加一个双亲域)

![Iamge](https://github.com/Feng-Jay/DataStruct/blob/master/Image/孩子双亲.png)
## 孩子兄弟表示法
又叫二叉树/二叉链表表示法。即链表中的两个链域分别指向该结点的**第一个**孩子结点与**下一个**兄弟结点。
```cpp
struct CSnode{
    elemtype data;
    CSnode* firstchild, *nextsibling;
};
typedef CSnode * CStree;
```
![Iamge](https://github.com/Feng-Jay/DataStruct/blob/master/Image/孩子兄弟.png)